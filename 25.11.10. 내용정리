Git 브랜치 병합(Merge) 핵심 정리

서론: 브랜치 병합의 중요성

Git의 merge는 분산된 여러 작업 흐름을 하나의 일관된 이력으로 통합하는 핵심 기능입니다. 팀원들이 각자의 브랜치에서 독립적으로 개발한 기능이나 수정한 버그를 메인 브랜치에 안전하게 합칠 수 있게 해주는 필수적인 과정입니다. 이 문서에서는 Git 브랜치 병합의 가장 기본적인 두 가지 방식인 'Fast-forward'와 '3-Way Merge'를 시작으로, 프로젝트의 필요에 따라 병합 전략을 제어하는 다양한 옵션, 그리고 협업 과정에서 필연적으로 마주하게 되는 '병합 충돌(Merge Conflict)'의 원인과 해결 방법까지 체계적으로 정리합니다.


--------------------------------------------------------------------------------


1. 병합의 두 가지 기본 방식: Fast-forward vs. 3-Way Merge

Git은 병합을 시도할 때 두 브랜치의 커밋 이력(history) 관계를 분석하여 자동으로 가장 적합한 병합 방식을 선택합니다. 이 두 가지 기본 방식인 'Fast-forward'와 '3-Way Merge'의 동작 조건과 결과를 이해하는 것은 효과적인 브랜치 관리의 첫걸음입니다.

빨리 감기 (Fast-forward) 병합

'Fast-forward' 병합은 말 그대로 브랜치의 이력을 빨리 감기 하듯 앞으로 이동시키는 가장 단순한 형태의 병합입니다.

* 조건: 병합하려는 브랜치(bugfix 등)의 이력이 현재 브랜치(master 등)의 이력 위에 순차적으로 쌓여 있는, 즉 두 브랜치가 '일렬 상태'일 때 발생합니다. 이는 현재 브랜치가 대상 브랜치의 직접적인 조상(ancestor)임을 의미합니다.
* 동작 방식: 새로운 병합 커밋을 생성하는 것이 아니라, 사실상 '병합할 새로운 내용이 없으므로' 현재 브랜치가 가리키는 포인터(HEAD)를 대상 브랜치의 최신 커밋으로 단순히 '이동'시키기만 합니다.
* 결과: 커밋 이력이 분기 없이 하나의 직선으로 깔끔하게 유지됩니다.

상태	                      설명
병합 전          	master 브랜치가 커밋 B를, bugfix 브랜치가 커밋 Y를 가리키고 있으며, master가 bugfix의 직접적인 조상인 일렬 상태입니다. (이력: A -> B(master) -> Y(bugfix))
병합 후	          master 포인터가 bugfix와 동일한 커밋 Y로 '빨리 감기'처럼 이동합니다. 별도의 병합 커밋은 생성되지 않습니다.

3-Way 병합

'3-Way' 병합은 두 브랜치가 공통의 조상으로부터 갈라져 나와 각자 다른 이력을 쌓았을 때 사용되는 방식입니다.

* 조건: 두 브랜치가 공통 조상 커밋 이후 각자의 경로로 커밋을 생성하여 이력이 '분기된 상태'일 때 발생합니다.
* 동작 방식: Git은 3개의 지점, 즉 1) 공통 조상 커밋, 2) 현재 브랜치의 최신 커밋, 3) 대상 브랜치의 최신 커밋을 비교하여 양쪽의 변경 사항을 모두 통합한 새로운 '병합 커밋(merge commit)'을 생성합니다.
* 결과: 분기되었던 두 작업 이력을 하나로 합친 새로운 병합 커밋이 생성됩니다. 이를 통해 어떤 브랜치의 작업 내역이 언제 통합되었는지 명확한 이력을 남길 수 있습니다.

상태	            설명
병합 전        	master와 bugfix 브랜치가 공통 조상 커밋 A로부터 갈라져 각각 다른 커밋 C와 D를 가진 상태입니다.
병합 후	        두 브랜치의 변경 사항(C, D)을 모두 포함하는 새로운 병합 커밋 E가 생성되고, master는 이 새로운 커밋을 가리킵니다.

이 두 가지 기본 방식의 동작 원리를 이해했다면, 이제 특정 목적을 위해 병합 동작을 의도적으로 제어하는 다양한 옵션에 대해 알아볼 차례입니다.


--------------------------------------------------------------------------------


2. 병합 전략 제어를 위한 주요 옵션

Git의 기본 병합 동작은 대부분의 상황에서 효율적이지만, 프로젝트의 이력 관리 정책이나 팀의 협업 스타일에 따라 병합 전략을 의도적으로 제어해야 할 때가 있습니다. --no-ff, --squash, --ff-only와 같은 주요 옵션들은 개발자가 더 명확하고 의도적인 커밋 히스토리를 만드는 데 큰 도움을 줍니다.

병합 이력 남기기: --no-ff

* 목적: Fast-forward가 가능한 '일렬 상태'의 브랜치를 병합할 때도, 의도적으로 새로운 병합 커밋을 생성하여 3-Way 병합을 수행하도록 강제하는 옵션입니다.
* 전략적 가치: 이 옵션을 사용하면 특정 기능 개발이나 버그 수정이 별도의 브랜치에서 진행되었다는 사실을 커밋 이력에 명확하게 남길 수 있습니다. 이는 단순히 이력을 남기는 것을 넘어, 특정 기능이 어떤 커밋들로 구성되었는지 명확한 경계를 만들어주므로 코드 리뷰, 버그 발생 시 원인 추적(bisect), 릴리스 노트 작성 등을 매우 용이하게 만듭니다.
* 명령어: git merge --no-ff {병합할 브랜치 명}

커밋 내역 합치기: --squash

* 목적: 대상 브랜치에 존재하는 여러 개의 자잘한 커밋들을 하나의 의미 있는 변경사항으로 '짓뭉개서(squash)' 현재 브랜치에 적용하는 방식입니다.
* 핵심 과정: 이 옵션은 다른 병합과 달리 자동 커밋을 수행하지 않습니다. git merge --squash {브랜치} 명령을 실행하면, 대상 브랜치의 모든 변경 사항이 현재 브랜치의 스테이징 영역에 추가된 상태로 멈춥니다. 이후 개발자가 직접 git commit 명령을 실행하여 원하는 메시지와 함께 단 하나의 새로운 커밋을 생성해야 하는 2단계 프로세스입니다.
* 전략적 가치: 기능 개발 과정에서 발생한 사소한 수정("오타 수정", "리팩토링" 등) 커밋들을 모두 숨기고, 최종적으로 완성된 기능에 대한 단 하나의 깔끔한 커밋만 main 브랜치에 남기고 싶을 때 매우 유용합니다. 이 방식은 대상 브랜치의 개별 커밋 이력을 병합 이력에 남기지 않습니다. 또한, 병합 후에도 원본 기능 브랜치(topic 등)는 그대로 남아있기 때문에, 병합된 내용과 별개로 해당 브랜치에서 추가 작업을 이어갈 수도 있습니다. 이는 일반적인 3-Way 병합과 다른 점입니다.

직선 이력 유지하기: --ff-only

* 목적: 오직 Fast-forward가 가능한 경우에만 병합을 허용하는, 보다 엄격한 옵션입니다.
* 전략적 가치: main 또는 master와 같은 핵심 브랜치의 커밋 이력을 복잡한 병합 커밋 없이 항상 깨끗한 직선 형태로 유지하고자 하는 정책을 강제할 때 유용합니다. 만약 두 브랜치가 분기되어 3-Way Merge가 필요한 상황이라면, 이 옵션을 사용한 병합은 실패하며 개발자에게 다른 조치(예: rebase)를 취하도록 유도합니다.
* 명령어: git merge --ff-only {병합할 브랜치 명}

이처럼 다양한 옵션을 통해 병합 전략을 제어할 수 있지만, 여러 사람이 동시에 같은 부분을 수정하다 보면 병합이 순조롭게 진행되지 않는 경우가 있습니다. 다음 섹션에서는 이러한 '병합 충돌' 상황을 다룹니다.


--------------------------------------------------------------------------------


3. 병합 충돌(Merge Conflict)의 이해와 해결

병합 충돌은 Git을 사용한 협업 환경에서 피할 수 없는 자연스러운 과정이며, 결코 두려워할 대상이 아닙니다. Git은 충돌 발생 시 작업을 중단하고 개발자에게 명확한 표식을 남겨 문제 해결의 주도권을 넘겨줍니다. 이 과정을 이해하면 충돌은 더 이상 문제가 아니라, 팀의 변경 사항을 조율하는 하나의 과정이 됩니다. 충돌이 발생하는 원인을 정확히 이해하고, Git이 충돌을 어떻게 표시하는지 파악한 뒤, 체계적인 절차에 따라 해결하는 방법을 익히는 것이 중요합니다.

병합 충돌의 원인

* 발생 조건: 병합 충돌은 3-Way 병합을 시도하는 과정에서, 두 개의 다른 브랜치가 동일한 파일의 동일한 부분을 서로 다르게 수정했을 때 발생합니다. Git은 어떤 변경 사항을 최종본으로 선택해야 할지 자동으로 판단할 수 없으므로, 사용자에게 직접 해결을 요청하게 됩니다.
* 충돌 없음 (자동 병합 가능):
  * 한쪽 브랜치에서만 파일을 수정하고 다른 쪽은 건드리지 않은 경우 (예: main에서만 파일 A 수정)
  * 두 브랜치가 서로 다른 파일을 수정한 경우 (예: main은 파일 A를, topic은 파일 B를 수정)
* 충돌 발생 (수동 해결 필요):
  * 두 브랜치가 동일한 파일의 동일한 영역을 각자 다르게 수정한 경우 (예: main과 topic 모두 파일 C의 5번째 줄을 수정)

충돌 해결 절차

Git은 충돌이 발생하면 병합을 일시 중단하고, 충돌이 발생한 파일 내부에 특수한 표시(marker)를 남겨 문제의 위치를 알려줍니다.

* 충돌 확인: 파일 내부에 <<<<<<< HEAD, =======, >>>>>>> {브랜치명} 와 같은 표시가 나타납니다.
  * <<<<<<< HEAD 부터 ======= 까지는 현재 브랜치(HEAD)의 변경 내용을 의미합니다.
  * ======= 부터 >>>>>>> {브랜치명} 까지는 병합하려는 대상 브랜치의 변경 내용을 의미합니다.
* 해결 절차: 충돌은 다음의 명확한 단계를 통해 해결할 수 있습니다.
  1. 충돌이 발생한 파일을 코드 에디터로 엽니다.
  2. <<<<<<<, =======, >>>>>>> 표시를 모두 제거하고, 두 브랜치의 변경 내용을 비교하여 최종적으로 남길 코드로 직접 수정합니다. 양쪽의 코드를 모두 남기거나, 한쪽만 선택하거나, 완전히 새로운 코드를 작성할 수도 있습니다.
  3. 수정이 완료된 파일을 저장한 후 git add {파일명} 명령어로 스테이징 영역에 추가합니다. 이 단계는 Git에게 '사용자가 직접 충돌을 확인하고 책임 하에 최종 버전을 결정했음'을 공식적으로 알리는 행위이며, 이 과정을 거치지 않으면 병합을 완료할 수 없습니다.
  4. 모든 충돌 파일을 add 했다면, git commit 명령어를 실행하여 병합을 완료하는 새로운 커밋을 생성합니다.

병합 작업 취소하기

병합 과정이 예상보다 복잡하거나 충돌 해결이 어렵다고 판단될 때, 병합 시도 자체를 없던 일로 되돌릴 수 있습니다.

* 명령어: git merge --abort 명령어를 사용하면, 병합을 시도하기 이전의 깨끗한 상태로 안전하게 되돌아갈 수 있습니다.

병합의 기본 원리부터 고급 옵션, 그리고 가장 까다로운 충돌 해결까지 다루었습니다. 마지막으로, 학습한 내용을 빠르게 찾아볼 수 있도록 핵심 명령어를 요약하며 문서를 마무리합니다.


--------------------------------------------------------------------------------


4. 핵심 명령어 요약

이 섹션은 본문에서 다룬 다양한 Git 병합 관련 명령어들을 한눈에 확인하고 필요할 때 빠르게 찾아볼 수 있도록 정리한 참조 가이드입니다.

명령어	                                        기능 설명	                                                                                주요 사용 사례
git merge {branch}	                기본 병합: 브랜치 이력에 따라 Fast-forward 또는 3-Way 병합을 자동으로 수행합니다.	          가장 일반적인 브랜치 통합 시 사용합니다.
git merge --no-ff {branch}	        병합 커밋 강제 생성: Fast-forward가 가능해도 의도적으로 병합 커밋을 남깁니다.	              기능 브랜치의 작업 이력을 명확히 남기고 싶을 때 사용합니다.
git merge --ff-only {branch}	      Fast-forward 병합만 허용: Fast-forward가 불가능하면 병합을 중단합니다.                    	메인 브랜치의 이력을 항상 직선으로 깔끔하게 유지하고 싶을 때 사용합니다.
git merge --squash {branch}	        커밋 내역 통합: 대상 브랜치의 여러 커밋을 하나의 변경사항으로 합칩니다.                       (별도의 git commit 필요)	자잘한 커밋 내역 없이, 완성된 기능 하나만 깔끔하게 반영하고 싶을 때 사용합니다.
git merge --abort	                  병합 취소: 병합 충돌이 발생했을 때, 병합 작업을 시작하기 전 상태로 되돌립니다.	              충돌 해결이 복잡하거나 병합을 원치 않을 때 안전하게 작업을 취소합니다.
