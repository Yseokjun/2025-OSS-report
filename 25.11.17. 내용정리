Git 고급 활용법: Rebase, 커밋 수정, 그리고 VS Code 연동 핵심 정리

서론: 깔끔한 Git 히스토리 관리의 중요성

본 문서는 제공된 강의 자료를 바탕으로 개인적인 복습을 위해 Git의 고급 기능들을 종합적으로 정리한 것입니다. 프로젝트의 이력을 깨끗하고 가독성 높게, 그리고 전문적으로 관리하기 위해서는 rebase를 통한 히스토리 재정렬, 커밋 수정, 그리고 VS Code와의 연동 기능을 숙달하는 것이 매우 중요합니다. 이러한 기술들은 협업의 효율성을 높이고 유지보수를 용이하게 만드는 핵심 역량이 됩니다.

이 문서에서는 다음 세 가지 핵심 주제를 다룰 것입니다.

1. rebase를 활용한 브랜치 히스토리 재정렬
2. amend와 interactive rebase를 통한 완벽한 커밋 히스토리 관리
3. Visual Studio Code를 이용한 실전적인 Git 활용법


--------------------------------------------------------------------------------


1. 브랜치 히스토리 재정렬: git rebase 마스터하기

1.1. rebase의 핵심 개념과 목적

rebase는 전략적으로 Git 히스토리를 관리하기 위한 강력한 도구입니다. 이 기능의 주된 목적은 특정 브랜치의 베이스(base)를 다른 브랜치(master 등)의 최신 커밋으로 재배치하여, 마치 처음부터 최신 버전에서 작업을 시작한 것처럼 만들어 선형적이고 깔끔한 커밋 히스토리를 구성하는 것입니다.

여기서 '베이스'란 두 브랜치가 갈라지기 시작한 공통 조상 커밋을 의미합니다. 예를 들어 master 브랜치의 특정 커밋에서 bugfix 브랜치가 분기되었다면, 해당 공통 커밋이 두 브랜치의 베이스가 됩니다.

git rebase master 명령을 실행하면, bugfix 브랜치에만 존재하던 커밋들이 master 브랜치의 최신 커밋 바로 뒤로 이동하게 됩니다. 그 결과, 분기되었던 히스토리가 하나의 깔끔한 줄기로 합쳐져 프로젝트의 진행 과정을 훨씬 쉽게 파악할 수 있습니다.

이처럼 rebase는 깨끗한 히스토리를 만드는 데 유용하지만, 전통적인 병합 방식과는 근본적인 차이가 있으므로 그 차이점을 명확히 이해하는 것이 중요합니다.

1.2. 병합 방식 비교 분석: 3-way merge vs. rebase

프로젝트의 상황과 팀의 정책에 따라 적절한 병합 전략을 선택하는 것은 매우 중요합니다. 이 섹션에서는 가장 일반적인 3-way merge 방식과 rebase 방식의 결과물이 어떻게 다른지 직접 비교하여 각각의 장단점을 분석합니다.

3-way merge                                                                                            	rebase
모든 브랜치의 분기 이력을 그대로 보존합니다. 이로 인해 프로젝트 로그가 복잡해질 수 있습니다.	        히스토리를 선형적으로 재구성하여 단순하고 깨끗한 로그를 만듭니다.
브랜치의 생성과 병합 등 모든 기록을 정확하게 남겨야 하는 프로젝트에 적합합니다.                    	커밋 히스토리를 재작성하므로, 여러 사람이 공유하며 작업하는 원격 브랜치에는 절대 사용해서는 안 됩니다.

결론적으로 rebase는 두 단계의 과정을 거쳐 실질적으로 적용되며, 다음 섹션에서 그 실행 과정을 자세히 살펴보겠습니다.

1.3. rebase 실행 과정 및 충돌 해결

rebase를 활용한 병합 흐름은 단순히 브랜치를 재배치하는 것에서 끝나지 않습니다. 재배치 후 주 브랜치를 업데이트하기 위한 추가적인 병합 과정이 필요합니다.

아래는 rebase와 merge를 함께 사용하는 2단계 과정입니다.

1. git rebase <target_branch> feature 브랜치에서 git rebase master와 같이 명령을 실행하면, 현재 브랜치의 커밋들이 대상 브랜치(master)의 최신 커밋 위로 하나씩 다시 적용(replays)됩니다. 이 과정에서 브랜치의 베이스가 변경됩니다.
2. git merge <feature_branch> rebase가 완료된 후, 대상 브랜치(master)로 이동하여(git checkout master) 재배치된 feature 브랜치를 병합합니다. 이때 병합은 단순히 HEAD 포인터만 이동시키는 fast-forward merge 방식으로 완료됩니다. 이는 rebase 작업을 통해 feature 브랜치의 히스토리가 대상 브랜치의 히스토리를 잇는 직접적인 선형 구조가 되었기 때문입니다. 더 이상 통합해야 할 분기점이 없으므로, Git은 master 브랜치 포인터를 feature 브랜치의 끝으로 빠르게 이동시켜 새로운 병합 커밋 없이 통합을 완료합니다.

rebase 중 충돌 해결

rebase는 각 커밋을 순서대로 다시 적용하는 과정이므로, 이동되는 커밋마다 충돌이 발생할 수 있습니다. 충돌이 발생하면 rebase 과정이 일시 중지되며, 다음 절차에 따라 해결해야 합니다.

1. 파일 수정: 충돌이 발생한 파일을 열어 직접 코드를 수정하여 문제를 해결합니다.
2. 파일 추가: git add <수정파일> 명령을 사용하여 해결된 파일을 스테이징 영역에 추가합니다.
3. rebase 계속 수행: git rebase --continue 명령을 실행하여 중단되었던 rebase 과정을 계속 진행합니다. 남은 커밋들에 대해서도 이 과정을 반복할 수 있습니다.

rebase가 브랜치 전체의 히스토리를 재구성하는 데 최적화되어 있다면, 이제 우리의 초점은 그 히스토리를 구성하는 원자 단위, 즉 개별 커밋으로 좁혀집니다. 깔끔한 히스토리를 위해서는 브랜치를 재정렬하는 것뿐만 아니라, 병합을 고려하기 전에 커밋 자체를 완벽하게 다듬는 과정이 종종 필요합니다.


--------------------------------------------------------------------------------


2. 완벽한 커밋 이력 관리: 수정 및 재구성

2.1. 최신 커밋 빠르게 수정하기: git commit --amend

git commit --amend는 가장 최근의 커밋을 빠르고 간편하게 수정할 수 있는 강력한 도구입니다. 커밋 메시지의 오타를 수정하거나 빠뜨린 파일을 추가하기 위해 불필요한 "fix" 커밋을 남기지 않고, 기존 커밋을 완벽하게 대체할 수 있습니다.

git commit --amend의 주요 사용 사례는 다음과 같습니다.

* 커밋 메시지 수정 (편집기 사용): git commit --amend 명령을 실행하면 설정된 기본 텍스트 편집기가 열리며, 여기서 마지막 커밋의 메시지를 자유롭게 수정할 수 있습니다.
* 커밋 메시지 수정 (명령어 직접 입력): git commit --amend -m "새로운 커밋 메시지"와 같이 -m 옵션을 사용하여 명령줄에서 바로 메시지를 수정할 수 있습니다.
* 최신 커밋에 파일 추가/수정: 수정하거나 추가할 파일을 스테이징(git add ...)한 후, git commit --amend를 실행하면 해당 변경사항이 새로운 커밋이 아닌 이전 커밋에 통합됩니다. 이때 커밋 메시지를 변경할 필요가 없다면 --no-edit 플래그를 추가하여 편집기 실행을 건너뛸 수 있습니다.

중요: --amend 옵션을 사용하면 기존 커밋을 수정하는 것이 아니라, 수정된 내용을 담은 새로운 커밋 ID를 가진 커밋이 생성되어 기존 커밋을 대체한다는 점을 반드시 기억해야 합니다.

--amend는 가장 최근의 커밋 하나에만 유용합니다. 만약 더 오래된 여러 개의 커밋을 수정해야 한다면 더 강력한 도구가 필요합니다.

2.2. 여러 커밋 한 번에 편집하기: git rebase --interactive

git rebase --interactive(또는 -i)는 오래된 여러 개의 커밋을 재작성하고, 순서를 변경하며, 하나로 합치는 등 히스토리 자체를 편집할 수 있는 가장 강력하고 유연한 도구입니다.

기본적인 명령어 구조는 git rebase -i HEAD~N 형태입니다. 여기서 HEAD~N은 편집할 범위의 '기준점'이 되는 커밋을 지정하며, 이 커밋은 편집 목록에 포함되지 않습니다. 즉, git rebase -i HEAD~3을 실행하면 최신 커밋부터 시작해 총 3개(HEAD, HEAD1, HEAD2)의 커밋이 편집 목록에 나타납니다.

명령을 실행하면 기본 텍스트 편집기에 수정 가능한 커밋 목록이 열립니다. 일반적인 git log와는 반대로, 가장 오래된 커밋이 맨 위에 표시되는 순서입니다. 각 커밋 앞에는 기본적으로 pick이라는 명령어가 붙어 있으며, 이 명령어를 변경하여 원하는 작업을 수행할 수 있습니다.

명령어 (Command)	                약어 (Abbreviation)	                      설명 (Description)
pick	                                p                      	해당 커밋을 변경 없이 그대로 사용합니다.
reword                              	r                      	커밋은 유지하되, 커밋 메시지를 수정합니다.
squash	                              s	                      해당 커밋을 리스트에서 바로 위에 있는(더 오래된) 커밋과 하나로 합칩니다. 커밋 메시지를 새로 작성할 수 있습니다.
drop                                	d	                      해당 커밋을 완전히 삭제합니다.

다음 섹션에서는 이러한 강력한 기능들을 VS Code 환경에서 어떻게 시각적으로 활용할 수 있는지 살펴보겠습니다.


--------------------------------------------------------------------------------


3. 시각적 Git 활용: Visual Studio Code 연동

3.1. VS Code에서의 Git 기본 작업 흐름

VS Code와 같은 그래픽 인터페이스(GUI)를 사용하면 복잡한 Git 명령어 없이도 직관적으로 버전 관리 작업을 수행할 수 있습니다. 특히 소스 제어(Source Control) 패널은 저장소 초기화부터 커밋에 이르는 전 과정을 시각적으로 관리하게 해줍니다.

VS Code에서의 기본적인 Git 작업 흐름은 다음과 같습니다.

* 저장소 초기화 (Initialize Repository): 작업 폴더를 연 상태에서 소스 제어 액티비티 바 아이콘을 클릭하고 '저장소 초기화' 버튼을 눌러 Git 관리를 시작합니다.
* 변경 사항 확인 (Changes): 'Changes' 섹션에는 작업 디렉토리(Working Directory)에서 수정되었지만 아직 스테이징되지 않은 파일 목록이 표시됩니다.
* 변경 사항 스테이징 (Staged Changes): 'Staged Changes' 섹션에는 스테이징 영역(Index)에 추가되어 커밋을 대기 중인 파일 목록이 표시됩니다.
* 커밋 (Commit): 상단의 입력란에 커밋 메시지를 작성하고 커밋 버튼을 클릭하면 'Staged Changes'에 있던 모든 파일이 하나의 커밋으로 기록됩니다.

또한 VS Code 인터페이스를 통해 변경 사항을 쉽게 폐기할 수 있으며, 이는 CLI 명령어와 직접적으로 연관됩니다.

* git restore (Discard Changes): 'Changes' 섹션의 파일에서 '변경 내용 취소'를 실행하면, 해당 파일의 작업 디렉토리 내용이 스테이징 영역의 상태로 되돌아갑니다.
* git restore --staged (Unstage Changes): 'Staged Changes' 섹션의 파일에서 '스테이징 취소'를 실행하면, 해당 파일이 스테이징 영역에서 제거됩니다. 파일의 작업 디렉토리 버전은 변경되지 않으며, 단지 다음 커밋에 포함될 목록에서만 빠지게 됩니다.

기본적인 작업을 넘어, VS Code의 강력한 비교 기능을 활용하면 작업 효율을 더욱 높일 수 있습니다.

3.2. Git Graph 확장 프로그램을 활용한 히스토리 탐색 및 비교

커밋 히스토리를 시각적으로 파악하는 것은 프로젝트의 흐름을 이해하는 데 매우 중요합니다. VS Code의 Git Graph 확장 프로그램은 브랜치 관계, 병합 지점, 그리고 전체 커밋 이력을 그래프 형태로 보여주어 복잡한 히스토리를 한눈에 파악할 수 있게 돕는 필수 도구입니다.

확장 프로그램 마켓플레이스에서 "Git Graph"를 검색하여 설치한 후, 소스 제어 패널 상단 아이콘이나 상태 표시줄의 버튼을 통해 그래프를 열 수 있습니다.

Git Graph와 VS Code의 기본 기능을 활용하면 다양한 파일 비교(diff) 작업을 직관적으로 수행할 수 있습니다.

* Working Directory vs. Staging Area (git diff): 소스 제어 패널의 'Changes' 섹션에 있는 파일을 클릭하면, 현재 작업 중인 내용과 스테이징된 내용 간의 차이를 보여줍니다.
* Staging Area vs. Last Commit (git diff --staged): 'Staged Changes' 섹션에 있는 파일을 클릭하면, 스테이징된 내용과 마지막 커밋의 내용 간의 차이를 보여줍니다.
* Comparing Commits (git diff <commit1> <commit2>): Git Graph 뷰에서 특정 커밋을 클릭하면 해당 커밋에서 변경된 파일 목록과 그 내용을 볼 수 있습니다. 이 작업은 선택한 커밋과 그 부모 커밋을 비교하는 것과 같습니다. 예를 들어, 소스 자료의 git diff HEAD~2 HEAD^ 명령은 Git Graph에서 HEAD^에 해당하는 커밋을 클릭함으로써 동일한 비교 결과를 시각적으로 확인할 수 있습니다.


--------------------------------------------------------------------------------


4. 핵심 요약 및 최종 복습

이 문서는 깨끗하고 관리하기 쉬운 Git 히스토리를 만들기 위한 고급 기법들을 다루었습니다. rebase를 통한 히스토리 재정렬부터 amend와 interactive rebase를 이용한 커밋 수정, 그리고 VS Code를 활용한 시각적 작업까지, 전문적인 Git 활용을 위한 핵심 개념들을 살펴보았습니다.

아래는 빠른 복습을 위한 가장 중요한 명령어와 개념 요약입니다.

* git rebase: 히스토리를 선형적으로 만들어 가독성을 높이지만, 공유된 브랜치에서는 사용에 주의해야 합니다.
* git commit --amend: 마지막 커밋의 메시지나 내용을 간편하게 수정할 때 사용합니다.
* git rebase -i HEAD~N: 여러 개의 이전 커밋을 reword, squash, drop 등의 명령어로 자유롭게 편집할 수 있는 가장 강력한 히스토리 수정 도구입니다.
* VS Code Source Control: Changes(Working Directory)와 Staged Changes(Staging Area)를 시각적으로 구분하여 직관적인 Git 작업이 가능하게 합니다.
* Git Graph Extension: 복잡한 브랜치 구조와 커밋 이력을 시각적으로 탐색하고 파일 변경 내역을 쉽게 비교할 수 있도록 돕는 필수 확장 프로그램입니다.
