
1. Git의 기본 개념: 3가지 핵심 영역 (Git's Fundamental Concepts: The 3 Core Areas)

Git의 모든 버전 관리 작업은 3가지 핵심 영역(Working Directory, Staging Area, Git Repository)을 기반으로 이루어집니다. 이 구조를 이해하는 것은 Git을 효과적으로 사용하는 데 있어 가장 기본적이고 전략적인 첫걸음입니다. 각 영역은 고유한 역할을 수행하며, 파일의 변경사항이 최종적으로 저장소에 기록되기까지의 과정을 관리합니다.

영역 (Area)	                              다른 이름 (Alternative Names)	              역할 및 설명 (Role & Description)
작업 디렉토리 (Working Directory)	        working tree / working folder	          사용자가 실제 파일을 수정하고 작업하는 공간. 탐색기에서 보이는 실제 프로젝트 폴더에 해당합니다.
스테이징 영역 (Staging Area)                        	index	                        커밋할 변경사항을 선별하여 준비시키는 임시 공간입니다. 저장소의 .git 폴더 내 index 파일에 의해 관리됩니다.
깃 저장소 (Git Repository)                        	repository	                    파일의 특정 시점 버전(스냅샷)이 영구적으로 저장되는 공간입니다. .git 폴더 내의 여러 정보로 구성됩니다.

--------------------------------------------------------------------------------

2. 버전 생성: add 와 commit (Creating a Version: add and commit)

Git에서 하나의 버전(커밋)을 생성하는 과정은 의도적인 2단계 절차로 이루어집니다. add 명령어로 변경사항을 스테이징 영역에 준비시키고, commit 명령어로 해당 내용을 저장소에 영구적으로 기록합니다. 이 과정을 통해 변경사항은 작업 디렉토리에서 스테이징 영역을 거쳐 깃 저장소로 이동하게 됩니다.

2.1. 작업 상태 확인: git status

git status 명령어는 현재 저장소의 상태를 확인하는 데 필수적입니다. 파일의 수정 상태와 각 파일이 어느 영역에 위치하는지를 명확히 보여주어 다음 작업을 결정하는 데 도움을 줍니다.

* ?? (Untracked file): Git이 아직 추적하고 있지 않은 새로 생성된 파일입니다. git status 출력에서 붉은색으로 표시됩니다.
* A (new file): git add 명령어를 통해 스테이징 영역에 추가되어 커밋을 기다리는 새로운 파일입니다. 녹색으로 표시됩니다.
* M (Modified file - Red): Git이 이미 추적 중인 파일이 작업 디렉토리에서 수정되었지만 아직 스테이징되지 않은 상태를 의미합니다.
* M (Modified file - Green): 수정된 파일이 git add를 통해 스테이징 영역에 추가되어 다음 커밋에 포함될 준비가 완료된 상태를 의미합니다.

2.2. 변경사항 준비: git add

git add 명령어는 작업 디렉토리에서 발생한 변경사항(새 파일 또는 수정된 파일)을 스테이징 영역으로 옮기는 역할을 합니다. 이 과정을 '스테이징한다'고 표현하며, 커밋에 포함될 내용을 선별하는 단계입니다.

만약 스테이징 영역에 추가한 파일을 다시 작업 디렉토리 상태로 되돌리고 싶다면(Unstage), git rm --cached <file> 명령어를 사용할 수 있습니다.

2.3. 버전 저장: git commit

커밋(Commit)은 스테이징 영역에 준비된 파일들의 현재 상태에 대한 스냅샷을 찍어 깃 저장소에 영구적으로 저장하는 행위입니다. 모든 커밋은 프로젝트 이력을 관리하기 위해 반드시 커밋 메시지를 포함해야 합니다.

명령어 (Command)                          	설명 (Description)
git commit	                      기본 편집기를 실행하여 커밋 메시지를 상세히 입력합니다.
git commit -m 'message'	          커밋 메시지를 명령어 라인에서 직접 입력하여 간편하게 커밋합니다.
git commit -a -m 'message'        이미 추적 중인 파일의 수정사항을 add 하는 과정과 커밋을 한 번에 실행합니다. -a 옵션은 Git이 이미 추적하고 있는 파일에만 적용되므로, 추적되지 않는 새 파일은 포함되지 않습니다.
<br/>git commit -am 'message'

이렇게 커밋을 생성하고 나면, 프로젝트의 변경 이력이 차곡차곡 쌓이게 되며, 이를 조회하고 분석하는 작업이 중요해집니다.


--------------------------------------------------------------------------------


3. 커밋 이력 조회: log 와 show (Viewing Commit History: log and show)

버전이 저장소에 커밋되면 git log와 git show 명령어를 통해 프로젝트의 전체 이력을 탐색하거나 특정 시점의 변경사항을 상세히 확인할 수 있습니다. 이 명령어들은 시간의 흐름에 따른 변화를 이해하고 특정 버전을 식별하는 데 핵심적인 도구입니다.

3.1. 전체 이력 보기: git log

git log 명령어는 저장소에 기록된 커밋 이력을 최신순으로 보여줍니다. 기본 출력에는 각 커밋을 고유하게 식별하는 40자리의 16진수 SHA-1 해시인 커밋 ID, 작성자, 날짜, 그리고 커밋 메시지가 포함됩니다. 다양한 옵션을 조합하여 원하는 형태로 이력을 조회할 수 있습니다.

옵션 (Option)	              기능 및 효과 (Function & Effect)
--oneline            	각 커밋을 한 줄로 요약하여 표시합니다. 전체 커밋 ID의 첫 7자리와 메시지 제목으로 구성됩니다.
--patch 또는 -p	      각 커밋의 상세 정보와 함께 해당 커밋에서 변경된 파일의 내용(diff)까지 함께 표시합니다.
--graph              	브랜치와 병합 이력을 텍스트 기반의 그래프로 시각화하여 보여줍니다.
--all	                현재 브랜치뿐만 아니라 모든 브랜치의 커밋 이력을 함께 표시합니다.
-n <number>	          가장 최근의 <number>개 커밋만 표시합니다. (예: git log -2)
--reverse	            커밋 이력을 오래된 순서부터 최신 순으로 표시합니다.

3.2. 특정 커밋 상세 보기: git show

git show 명령어는 특정 커밋 한 개의 상세 정보와 변경 내용을 집중적으로 조회할 때 사용됩니다. 커밋 ID를 지정하지 않으면 가장 최근 커밋(HEAD)의 정보를 보여줍니다.

* git show: 가장 최근 커밋(HEAD)의 메타데이터와 파일 변경 내용을 표시합니다.
* git show [commitID]: 지정한 ID에 해당하는 커밋의 상세 정보를 표시합니다.
* git show HEAD~: 현재 커밋(HEAD) 바로 이전 커밋의 정보를 표시합니다. HEAD~2는 두 단계 이전 커밋을 의미합니다.
* git show --oneline: 커밋 정보를 한 줄로 요약하고, 그 아래에 파일 변경 내용을 함께 표시합니다.

단순히 이력을 조회하는 것을 넘어, 과거의 특정 시점으로 직접 돌아가 프로젝트 상태를 확인하는 것도 가능합니다.


--------------------------------------------------------------------------------


4. 과거로의 시간 여행: checkout (Time Travel to the Past: checkout)

Git의 git checkout 명령어는 프로젝트의 특정 과거 시점으로 "시간 여행"을 떠날 수 있게 해주는 강력한 기능입니다. 이를 통해 이전 버전의 코드를 직접 검토하고, 특정 시점의 프로젝트 상태를 확인하며, 변경 이력의 맥락을 깊이 있게 이해할 수 있습니다.

4.1. 이전 버전으로 이동

과거의 특정 커밋으로 이동하려면 git checkout [commitID] 명령어를 사용합니다. 커밋 ID 대신 HEAD~(이전 커밋) 또는 HEAD~2(두 단계 이전 커밋)와 같은 상대적인 참조를 사용할 수도 있습니다.

이전 커밋으로 이동하면 "detached HEAD" 상태가 됩니다. 이는 "HEAD가 마지막 커밋이 아닌 그 이전을 가리킨다는 의미"로, 현재 특정 브랜치의 끝을 가리키는 것이 아니라 특정 커밋 자체를 직접 가리키고 있음을 나타냅니다.

주의: 과거 커밋으로 checkout하기 위해서는 작업 디렉토리가 "clean" 상태, 즉 커밋되지 않은 변경사항이 없어야 합니다. 만약 변경사항이 남아있다면, Git은 사용자의 미완성 작업을 덮어쓰는 것을 방지하기 위해 오류를 발생시킵니다. 이때 작업 디렉토리를 정리하는 두 가지 주요 방법이 있습니다.

* git stash (변경사항 임시 저장): 현재 작업 디렉토리와 스테이징 영역의 변경사항을 임시로 저장하여 보관하고, 작업 디렉토리를 마지막 커밋 상태로 깨끗하게 만듭니다. 나중에 다시 돌아와 stash에 저장된 작업을 복원할 수 있으므로, 유지하고 싶은 변경사항이 있을 때 사용합니다.
* git restore (변경사항 폐기): 작업 디렉토리의 변경사항을 폐기하고 파일을 마지막 커밋(HEAD) 상태로 되돌립니다. 이 방법은 버리고 싶은 변경사항이 있을 때 사용합니다.

4.2. 최신 버전으로 복귀

"detached HEAD" 상태에서 다시 최신 버전으로 돌아오는 방법은 간단합니다.

* git checkout main: main 브랜치의 가장 마지막 커밋으로 직접 이동합니다. 이 명령어는 HEAD 포인터를 다시 main 브랜치의 끝에 연결하여 "detached HEAD" 상태를 벗어나 안정적인 상태로 복귀시킵니다.
* git checkout -: 바로 이전에 있었던 커밋이나 브랜치로 되돌아가는 일종의 토글(toggle) 스위치입니다. checkout 명령어로 위치를 옮긴 직후 이전 위치로 빠르게 돌아갈 때 유용합니다.

add, commit, log, show, checkout과 같은 핵심 명령어들을 능숙하게 사용하면 프로젝트의 전체 버전 이력을 자유자재로 관리하고 제어할 수 있는 강력한 역량을 갖추게 됩니다.
